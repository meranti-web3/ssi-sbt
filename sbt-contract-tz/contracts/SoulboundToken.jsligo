#import "./NFT.jsligo" "NFT"
#import "./common/errors.mligo" "Errors"

type storage =
  {
    administrators: set<address>,
    ledger: NFT.Ledger.t,
    metadata: NFT.Metadata.t,
    token_metadata: NFT.TokenMetadata.t,
    current_token_id : nat
  };

type ret = [list<operation>, storage];

type transfer = list<{
   from_ : address,
   txs   : list<{
    to_      : address,
    token_id : nat,
    amount   : nat
  }>
}>

type parameter =
  | ["Mint", address, bytes]
  | ["Add_administrator", address]
  | ["Transfer", transfer]
  | ["Balance_of", NFT.balance_of];

const mint = (
  owner: address,
  ipfsUrl: bytes,
  s: storage
): ret => {
  if (!Set.mem(Tezos.get_sender(), s.administrators)) {
    failwith (Errors.not_owner);
  }

  const token_id = s.current_token_id;

  const token_info: map<string, bytes> =
    Map.literal(
      list(
        [
          ["name", (bytes `DeFi`)],
          ["description", (bytes `Proof of DeFi Compliance`)],
          ["interfaces", (bytes `["TZIP-12"]`)],
          ["uri", ipfsUrl],
          ["symbol", (bytes `DEFI`)],
          ["decimals", (bytes `0`)]
        ]
      )
    ) as map<string, bytes>;
  const metadata: bytes =
    bytes
    `{
      "name":"FA2 NFT Marketplace",
      "description":"Example of FA2 implementation",
      "version":"0.0.1",
      "license":{"name":"MIT"},
      "authors":["Marigold<contact@marigold.dev>"],
      "homepage":"https://marigold.dev",
      "source":{
        "tools":["Ligo"],
        "location":"https://github.com/ligolang/contract-catalogue/tree/main/lib/fa2"},
      "interfaces":["TZIP-012"],
      "errors": [],
      "views": []
      }`;
  return [
    list([]) as list<operation>,
    {
      ...s,
      ledger: Big_map.add(token_id, owner, s.ledger) as
        NFT.Ledger.t,
      metadata: Big_map.literal(
        list([["", bytes `tezos-storage:data`], ["data", metadata]])
      ),
      token_metadata: Big_map.add(
        token_id,
        { token_id: token_id, token_info: token_info },
        s.token_metadata
      ),
      current_token_id: token_id + (1 as nat)
    }
  ]
};

const main = ([p, s]: [parameter, storage]): ret =>
  match(
    p,
    {
      Mint: ([owner, ipfsUrl]: [address, bytes]) => {
        mint(owner, ipfsUrl, s);
      },
      Add_administrator: (p: address) => {
        if (Set.mem(Tezos.get_sender(), s.administrators)) {
          return [
            list([]),
            { ...s, administrators: Set.add(p, s.administrators) }
          ]
        } else {
          return failwith("1")
        }
      },
      Transfer: (_p: transfer) => {
        return failwith(Errors.no_transfer);
      },
      Balance_of: (p: NFT.balance_of) => {
        const ret2: [list<operation>, NFT.storage] =
          NFT.balance_of(
            p,
            {
              ledger: s.ledger,
              metadata: s.metadata,
              token_metadata: s.token_metadata,
              current_token_id: s.current_token_id
            }
          );
        return [
          ret2[0],
          {
            ...s,
            ledger: ret2[1].ledger,
            metadata: ret2[1].metadata,
            token_metadata: ret2[1].token_metadata,
            current_token_id: s.current_token_id
          }
        ]
      }
    }
  );