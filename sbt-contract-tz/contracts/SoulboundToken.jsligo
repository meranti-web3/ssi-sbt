type ipfs_url = string;

type owner = address;

type parameter =
  | ["Mint", owner, ipfs_url]
  | ["Burn", owner]
  | ["Add_admin", owner]
  | ["Remove_admin", owner];

type storage = {
  tokens: big_map<owner, ipfs_url>,
  admins: set<address>,
  name: string,
  symbol: string
};

type return_ = [list<operation>, storage];

const mint = (owner: owner, ipfs_url: ipfs_url, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins)) {
    return failwith("Access denied.")
  };
  return [
    list([]),
    { ...store, tokens: Big_map.add(owner, ipfs_url, store.tokens) }
  ]
};

const burn = (owner: owner, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins) || Tezos.get_sender() != owner) {
    return failwith("Access denied.")
  };
  return [list([]), { ...store, tokens: Big_map.remove(owner, store.tokens) }]
};

const add_admin = (admin: address, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins)) {
    return failwith("Access denied.")
  };
  return [list([]), { ...store, admins: Set.add(admin, store.admins) }]
};

const remove_admin = (admin: address, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins)) {
    return failwith("Access denied.")
  };
  return [list([]), { ...store, admins: Set.remove(admin, store.admins) }]
};

const main = (action: parameter, store: storage): return_ =>
  match(
    action,
    {
      Mint: ([owner, ipfs_url]: parameter) => mint(owner, ipfs_url, store),
      Burn: (owner: owner) => burn(owner, store),
      Add_admin: (admin: owner) => add_admin(admin, store),
      Remove_admin: (admin: owner) => remove_admin(admin, store)
    }
  );

// @view
const token_uri = (owner: owner, store: storage): ipfs_url =>
  Option.unopt_with_error(
    Big_map.find_opt(owner, store.tokens),
    "Owner doesn't have a token"
  );

// @view
const has_token = (owner: owner, store: storage): bool =>
  Big_map.mem(owner, store.tokens);
