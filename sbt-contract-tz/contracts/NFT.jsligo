// This file implement the TZIP-12 protocol (a.k.a FA2) for NFT on Tezos
// copyright Wulfman Corporation 2021

// Errors
#import "./common/errors.mligo" "Errors"

namespace Ledger {
   type token_id = nat;
   type owner = address;
   type last_token_id = nat;
   export type t = big_map<token_id,owner>;

   export const is_owner_of = (ledger: t, token_id: token_id, owner: address): bool => {
      const current_owner = Option.unopt (Big_map.find_opt (token_id, ledger));
      return (current_owner == owner);
   };
};

export namespace TokenMetadata {
   export type data = {token_id:nat,token_info:map<string,bytes>};
   export type t = big_map <nat, data>;

   export const get_token_metadata = (token_id: nat, tm: t) : data =>
      match (Big_map.find_opt (token_id, tm),
      {Some : (data : data) => data,
       None : () => failwith (Errors.undefined_token)});
};

#import "./common/metadata.mligo" "Metadata"

namespace Storage {
   type token_id = nat;
   export type t = {
      ledger : Ledger.t,
      token_ids : set<token_id>,
      token_metadata : TokenMetadata.t,
      metadata : Metadata.t
   };

   export const is_owner_of = (s: t, owner: address, token_id: token_id) : bool =>
      Ledger.is_owner_of (s.ledger, token_id, owner);

   export const assert_token_exist = (s: t, token_id: nat) : unit => {
      const _ = Option.unopt_with_error (Big_map.find_opt (token_id, s.token_metadata),
         Errors.undefined_token);
   };

   export const set_ledger = (s: t, ledger: Ledger.t) : t => ({...s, ledger : ledger});

   export const get_balance = (s: t, owner: address, token_id: nat) : nat => {
      assert_token_exist (s, token_id);
      if (is_owner_of (s, owner, token_id)) {
         return (1 as nat)
         } 
      else {
         return (0 as nat)
         }
   };
};


export type storage = Storage.t;

export type request = {
   owner    : address,
   token_id : nat,
};

type callback =
// @layout:comb
{
   request : request,
   balance : nat,
};

export type balance_of =
// @layout:comb
{
   requests : list<request>,
   callback : contract<list<callback>>,
};

// Balance_of entrypoint
const balance_of = (b: balance_of, s: storage): [list<operation>, storage] => {
   const {requests, callback} = b;
   const get_balance_info = (request : request) : callback => {
      const {owner,token_id} = request;
      Storage.assert_token_exist  (s, token_id);
      let balance_ = 0 as nat;
      if (Storage.is_owner_of (s, owner, token_id)) balance_ = 1 as nat;
      return ({request:request,balance:balance_});
   };
   const callback_param = List.map (get_balance_info, requests);
   const operation = Tezos.transaction (callback_param, (0 as tez), callback);
   return [list([operation]),s];
};

export type parameter =
// @layout:comb
| ["Balance_of", balance_of];

const main = (p: parameter, s: storage) : [list<operation>, storage] => {
   return match (p,
{  Balance_of       : (p : balance_of      ) => balance_of (p, s) });
}

// @view
const get_balance = ([p, s] : [[address , nat] , storage]) : nat => {
   const [owner, token_id] = p;
   return Storage.get_balance (s, owner, token_id);
};

// @view
const total_supply = ([token_id, s] : [nat , storage]) : nat => {
   Storage.assert_token_exist (s, token_id);
   return (1 as nat);
};

// @view
const all_tokens = ([_, s] : [unit , storage]) : set<nat> => s.token_ids;

// @view
const token_metadata = ([p, s] : [nat, storage]) : TokenMetadata.data =>
   TokenMetadata.get_token_metadata(p, s.token_metadata);

