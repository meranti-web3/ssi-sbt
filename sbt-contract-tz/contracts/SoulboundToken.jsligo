type ipfs_url = string;

type owner = address;

type transfer_params = {
  from_: address,
  tx: list<{ to_: address, token_id: nat }>
};

type request = { owner: address, token_id: nat };

type callback = { request, balance: nat };

type balance_of = {
  requests: list<request>,
  callback: contract<list<callback>>
};

type parameter =
  | ["Mint", owner, ipfs_url]
  | ["Burn", owner]
  | ["Add_admin", owner]
  | ["Remove_admin", owner]
  | ["Transfer", list<transfer_params>]
  | ["Balance_of", balance_of];

type storage = {
  tokens: big_map<owner, ipfs_url>,
  creation_dates: big_map<owner, timestamp>,
  admins: set<address>,
  name: string,
  symbol: string
};

type return_ = [list<operation>, storage];

const mint = (owner: owner, ipfs_url: ipfs_url, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins)) {
    return failwith("FA2_NOT_OPERATOR")
  };
  let new_tokens = Big_map.add(owner, ipfs_url, store.tokens);
  let new_creation_dates =
    Big_map.add(owner, Tezos.get_now(), store.creation_dates);
  return [
    list([]),
    { ...store, tokens: new_tokens, creation_dates: new_creation_dates }
  ]
};

const burn = (owner: owner, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins) && Tezos.get_sender() != owner) {
    return failwith("FA2_NOT_OPERATOR")
  };
  let new_tokens = Big_map.remove(owner, store.tokens);
  let new_creation_dates = Big_map.remove(owner, store.creation_dates);
  return [
    list([]),
    { ...store, tokens: new_tokens, creation_dates: new_creation_dates }
  ]
};

const add_admin = (admin: address, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins)) {
    return failwith("FA2_NOT_ADMIN")
  };
  return [list([]), { ...store, admins: Set.add(admin, store.admins) }]
};

const remove_admin = (admin: address, store: storage): return_ => {
  if (!Set.mem(Tezos.get_sender(), store.admins)) {
    return failwith("FA2_NOT_ADMIN")
  };
  return [list([]), { ...store, admins: Set.remove(admin, store.admins) }]
};

const transfer = (_transfer_params: list<transfer_params>, _store: storage)
  : return_ => { return failwith("FA2_TX_DENIED") };

const balance_of = (balance_of: balance_of, store: storage): return_ => {
  const { requests, callback } = balance_of;
  const get_balance_info = (request: request): callback => {
    // const { owner, token_id } = request;
    return ({ request: request, balance: 1 as nat })
  };
  const callback_param = List.map(get_balance_info, requests);
  const operation = Tezos.transaction(callback_param, (0 as tez), callback);
  return [list([operation]), store]
};

const main = (action: parameter, store: storage): return_ =>
  match(
    action,
    {
      Mint: ([owner, ipfs_url]: parameter) => mint(owner, ipfs_url, store),
      Burn: (o: owner) => burn(o, store),
      Add_admin: (a: owner) => add_admin(a, store),
      Remove_admin: (a: owner) => remove_admin(a, store),
      Transfer: (tp: list<transfer_params>) =>
        transfer(tp, store),
      Balance_of: (bo: balance_of) => balance_of(bo, store)
    }
  );

// @view
const token_uri = (owner: owner, store: storage): ipfs_url =>
  Option.unopt_with_error(
    Big_map.find_opt(owner, store.tokens),
    "Owner doesn't have a token"
  );

// @view
const token_creation_date = (owner: owner, store: storage): timestamp =>
  Option.unopt_with_error(
    Big_map.find_opt(owner, store.creation_dates),
    "Owner doesn't have a token"
  );

// @view
const has_token = (owner: owner, store: storage): bool =>
  Big_map.mem(owner, store.tokens);
